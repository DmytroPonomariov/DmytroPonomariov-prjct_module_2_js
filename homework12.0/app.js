console.log('start');

const promise1 = new Promise((resolve, reject) => {
console.log(1)
resolve(2)
})

promise1.then(res => {
console.log(res)
})

console.log('end');


// Спочатку виведе 'start' на початку. Далі записується проміс у змінну у статусі пендінг. Прийнявши два параметра  це колбеки. 
// Перший відповідає за переведення проміса у стан фулфілд, при його виклику аргументом в колбек передається результат операції. 
// Другий відповідає за переведення проміса у стан реджектет, при його виклику аргументом в колбек передається інформація про помилку.
// Потім виводиться - 1 в консолі. 
// Передається аргумент - 2 в колбек ресолв. І проміс переходть в стан фулфілд.
// Але далі в консоль виводить -'end'. Так як проміс асинхроний зен пропускається.
// Останнім приходить консоль з результатом виконання асихроної операції. Як це відувається.
// Аргумент колбека функції ресолв приймається як аргумент функції в зен. Повертаємо консоль з аргументом. 

Promise.resolve(1)
		.then((x) => x + 1)
		.then((x) => { throw new Error('My Error') })
		.catch(() => 1)
		.then((x) => x + 1)
		.then((x) => console.log(x))
		.catch(console.error)

// Тут послідовність слідуюча - є параметр з результатом 1. 
// Передається у зен колбек функцію параметром 1 і + 1 = 2.
// Але далі він не предається в ретерн. 
// ДАлі в кетч не попадаємо.
// Зен приймає 1 додається + 1 = 2
// Знову в зен і в консоль
// В еррор не попадаємо. 
